/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "unity.h"
#include "MockIO.h"

static struct MockIOInstance
{
  unsigned char allocFailure;

  int IO_Read_CallCount;
  int IO_Read_CallsExpected;

  ioData_t *IO_Read_Return;
  ioData_t *IO_Read_Return_Head;
  ioData_t *IO_Read_Return_Tail;

  ioAddress_t *IO_Read_Expected_offset;
  ioAddress_t *IO_Read_Expected_offset_Head;
  ioAddress_t *IO_Read_Expected_offset_Tail;

  int IO_Write_CallCount;
  int IO_Write_CallsExpected;

  ioAddress_t *IO_Write_Expected_offset;
  ioAddress_t *IO_Write_Expected_offset_Head;
  ioAddress_t *IO_Write_Expected_offset_Tail;

  ioData_t *IO_Write_Expected_data;
  ioData_t *IO_Write_Expected_data_Head;
  ioData_t *IO_Write_Expected_data_Tail;
} Mock;

extern jmp_buf AbortFrame;

void MockIO_Verify(void)
{
  TEST_ASSERT_EQUAL_MESSAGE(0, Mock.allocFailure, "Unable to allocate memory for mock");
  TEST_ASSERT_EQUAL_MESSAGE(Mock.IO_Read_CallsExpected, Mock.IO_Read_CallCount, "Function 'IO_Read' called unexpected number of times.");
  TEST_ASSERT_EQUAL_MESSAGE(Mock.IO_Write_CallsExpected, Mock.IO_Write_CallCount, "Function 'IO_Write' called unexpected number of times.");
}

void MockIO_Init(void)
{
  MockIO_Destroy();
}

void MockIO_Destroy(void)
{

  if (Mock.IO_Read_Return_Head)
  {
    free(Mock.IO_Read_Return_Head);
  }
  Mock.IO_Read_Return=NULL;
  Mock.IO_Read_Return_Head=NULL;
  Mock.IO_Read_Return_Tail=NULL;

  if (Mock.IO_Read_Expected_offset_Head)
  {
    free(Mock.IO_Read_Expected_offset_Head);
  }
  Mock.IO_Read_Expected_offset=NULL;
  Mock.IO_Read_Expected_offset_Head=NULL;
  Mock.IO_Read_Expected_offset_Tail=NULL;

  if (Mock.IO_Write_Expected_offset_Head)
  {
    free(Mock.IO_Write_Expected_offset_Head);
  }
  Mock.IO_Write_Expected_offset=NULL;
  Mock.IO_Write_Expected_offset_Head=NULL;
  Mock.IO_Write_Expected_offset_Tail=NULL;

  if (Mock.IO_Write_Expected_data_Head)
  {
    free(Mock.IO_Write_Expected_data_Head);
  }
  Mock.IO_Write_Expected_data=NULL;
  Mock.IO_Write_Expected_data_Head=NULL;
  Mock.IO_Write_Expected_data_Tail=NULL;
  memset(&Mock, 0, sizeof(Mock));
}

ioData_t IO_Read(ioAddress_t offset)
{

  Mock.IO_Read_CallCount++;
  if (Mock.IO_Read_CallCount > Mock.IO_Read_CallsExpected)
  {
    TEST_FAIL("Function 'IO_Read' called more times than expected");
  }

  if (Mock.IO_Read_Expected_offset != Mock.IO_Read_Expected_offset_Tail)
  {
    ioAddress_t* p_expected = Mock.IO_Read_Expected_offset;
    Mock.IO_Read_Expected_offset++;
    TEST_ASSERT_EQUAL_MEMORY_MESSAGE((void*)p_expected, (void*)&(offset), sizeof(ioAddress_t), "Function 'IO_Read' called with unexpected value for argument 'offset'.");

  }

  if (Mock.IO_Read_Return != Mock.IO_Read_Return_Tail)
  {
    ioData_t toReturn = *Mock.IO_Read_Return;
    Mock.IO_Read_Return++;
    return toReturn;
  }
  else
  {
    return *(Mock.IO_Read_Return_Tail - 1);
  }
}

void ExpectParameters_IO_Read(ioAddress_t offset)
{

  {
    int sz = 0;
    ioAddress_t *pointer = Mock.IO_Read_Expected_offset_Head;
    while (pointer && pointer != Mock.IO_Read_Expected_offset_Tail) { sz++; pointer++; }
    if (sz == 0)
    {
      Mock.IO_Read_Expected_offset_Head = (ioAddress_t*)malloc(2*sizeof(ioAddress_t));
      if (!Mock.IO_Read_Expected_offset_Head)
        Mock.allocFailure++;
    }
    else
    {
      ioAddress_t *ptmp = (ioAddress_t*)realloc(Mock.IO_Read_Expected_offset_Head, sizeof(ioAddress_t) * (sz+1));
      if (!ptmp)
        Mock.allocFailure++;
      else
        Mock.IO_Read_Expected_offset_Head = ptmp;
    }
    memcpy(&Mock.IO_Read_Expected_offset_Head[sz], &offset, sizeof(ioAddress_t));
    Mock.IO_Read_Expected_offset_Tail = &Mock.IO_Read_Expected_offset_Head[sz+1];
  }
  Mock.IO_Read_Expected_offset = Mock.IO_Read_Expected_offset_Head;
  Mock.IO_Read_Expected_offset += Mock.IO_Read_CallCount;
}

void IO_Read_ExpectAndReturn(ioAddress_t offset, ioData_t toReturn)
{
  Mock.IO_Read_CallsExpected++;
  ExpectParameters_IO_Read(offset);

  {
    int sz = 0;
    ioData_t *pointer = Mock.IO_Read_Return_Head;
    while (pointer && pointer != Mock.IO_Read_Return_Tail) { sz++; pointer++; }
    if (sz == 0)
    {
      Mock.IO_Read_Return_Head = (ioData_t*)malloc(2*sizeof(ioData_t));
      if (!Mock.IO_Read_Return_Head)
        Mock.allocFailure++;
    }
    else
    {
      ioData_t *ptmp = (ioData_t*)realloc(Mock.IO_Read_Return_Head, sizeof(ioData_t) * (sz+1));
      if (!ptmp)
        Mock.allocFailure++;
      else
        Mock.IO_Read_Return_Head = ptmp;
    }
    memcpy(&Mock.IO_Read_Return_Head[sz], &toReturn, sizeof(ioData_t));
    Mock.IO_Read_Return_Tail = &Mock.IO_Read_Return_Head[sz+1];
  }
  Mock.IO_Read_Return = Mock.IO_Read_Return_Head;
  Mock.IO_Read_Return += Mock.IO_Read_CallCount;
}

void IO_Write(ioAddress_t offset, ioData_t data)
{

  Mock.IO_Write_CallCount++;
  if (Mock.IO_Write_CallCount > Mock.IO_Write_CallsExpected)
  {
    TEST_FAIL("Function 'IO_Write' called more times than expected");
  }

  if (Mock.IO_Write_Expected_offset != Mock.IO_Write_Expected_offset_Tail)
  {
    ioAddress_t* p_expected = Mock.IO_Write_Expected_offset;
    Mock.IO_Write_Expected_offset++;
    TEST_ASSERT_EQUAL_MEMORY_MESSAGE((void*)p_expected, (void*)&(offset), sizeof(ioAddress_t), "Function 'IO_Write' called with unexpected value for argument 'offset'.");

  }

  if (Mock.IO_Write_Expected_data != Mock.IO_Write_Expected_data_Tail)
  {
    ioData_t* p_expected = Mock.IO_Write_Expected_data;
    Mock.IO_Write_Expected_data++;
    TEST_ASSERT_EQUAL_MEMORY_MESSAGE((void*)p_expected, (void*)&(data), sizeof(ioData_t), "Function 'IO_Write' called with unexpected value for argument 'data'.");

  }
}

void ExpectParameters_IO_Write(ioAddress_t offset, ioData_t data)
{

  {
    int sz = 0;
    ioAddress_t *pointer = Mock.IO_Write_Expected_offset_Head;
    while (pointer && pointer != Mock.IO_Write_Expected_offset_Tail) { sz++; pointer++; }
    if (sz == 0)
    {
      Mock.IO_Write_Expected_offset_Head = (ioAddress_t*)malloc(2*sizeof(ioAddress_t));
      if (!Mock.IO_Write_Expected_offset_Head)
        Mock.allocFailure++;
    }
    else
    {
      ioAddress_t *ptmp = (ioAddress_t*)realloc(Mock.IO_Write_Expected_offset_Head, sizeof(ioAddress_t) * (sz+1));
      if (!ptmp)
        Mock.allocFailure++;
      else
        Mock.IO_Write_Expected_offset_Head = ptmp;
    }
    memcpy(&Mock.IO_Write_Expected_offset_Head[sz], &offset, sizeof(ioAddress_t));
    Mock.IO_Write_Expected_offset_Tail = &Mock.IO_Write_Expected_offset_Head[sz+1];
  }
  Mock.IO_Write_Expected_offset = Mock.IO_Write_Expected_offset_Head;
  Mock.IO_Write_Expected_offset += Mock.IO_Write_CallCount;

  {
    int sz = 0;
    ioData_t *pointer = Mock.IO_Write_Expected_data_Head;
    while (pointer && pointer != Mock.IO_Write_Expected_data_Tail) { sz++; pointer++; }
    if (sz == 0)
    {
      Mock.IO_Write_Expected_data_Head = (ioData_t*)malloc(2*sizeof(ioData_t));
      if (!Mock.IO_Write_Expected_data_Head)
        Mock.allocFailure++;
    }
    else
    {
      ioData_t *ptmp = (ioData_t*)realloc(Mock.IO_Write_Expected_data_Head, sizeof(ioData_t) * (sz+1));
      if (!ptmp)
        Mock.allocFailure++;
      else
        Mock.IO_Write_Expected_data_Head = ptmp;
    }
    memcpy(&Mock.IO_Write_Expected_data_Head[sz], &data, sizeof(ioData_t));
    Mock.IO_Write_Expected_data_Tail = &Mock.IO_Write_Expected_data_Head[sz+1];
  }
  Mock.IO_Write_Expected_data = Mock.IO_Write_Expected_data_Head;
  Mock.IO_Write_Expected_data += Mock.IO_Write_CallCount;
}

void IO_Write_Expect(ioAddress_t offset, ioData_t data)
{
  Mock.IO_Write_CallsExpected++;
  ExpectParameters_IO_Write(offset, data);
}

